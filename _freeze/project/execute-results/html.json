{
  "hash": "c091758e80ed78eb1b3e1d0ef3c5b4f7",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Project\"\nformat:\n  html:\n    anchor-sections: true\n    fig-height: 3\n    fig-width: 4\n    fig-align: center\nfilters:\n  - pyodide\n---\n\n\n\n\n\nIf you are taking this course for graduate credit, you need to complete this project. The grade for the project will count in place of the active engagement grade. The project is due on the last day of class. \n\n**Note**: Undergraduate students are not required to complete this assignment, but can do so for fun and I would be happy to check your work, but it will not count towards your grade.\n\nThis project will teach you how to use Python programming to solve economic problems that involve optimization. Before you get started, you need to understand some basics of Python programming, so complete Tutorial 1 and then proceed to Tutorial 2, which teaches you how to solve an optimization problem in Python. In particular, Tutorial 2 will show you how to code a specific optimization problem. You will be modifying the code provided in this tutorial to solve a related but expanded problem as a part of your project. Once you are done with the two tutorials, you can start the project. You will find the instructions for the exercise you need to complete at the end of this document.\n\n# Tutorial 1: Basic Python Programming\n\n- Python is...\n- Usually how it works, you run something vs running on cloud\n- .py files and notebook files\n- I will not teach you workflow becuase this is not a programming class, but if you ever want to do anything serious, you need to learn that. \n- What we will do and see how programming can be used to solve economic models. \n- So we will use the simplest setup possible, which you should also be familar from your other classes, which is to use Jupyter notebook on Google Colab.\n\nYou can always play around with the code below and run it, modify it, etc. But remember once you refresh it it goes back to the original code. You can also copy code to your Jupyter notebooks in Google Colab and modify it there.\n\n```{pyodide-python}\nn = 5\nwhile n > 0:\n  print(n)\n  n = n - 1\n\nprint('Blastoff!')\n```\n\n## Packages and Syntax\n\n## Lists/vectors\n\n## Loops\n\n## Functions\n\n## Plots \n\n# Tutorial 2: Optimization in Python\n\nIn this tutorial, we’ll work through example 1 from the constrained optimization problems provided [here](Notes/Optimization-Examples.pdf). In particular, our optimization problem is as follows:\n\n$$ \\max_{x_1, x_2} \\quad x_1^{\\alpha} x_2^{\\beta} \\quad \\text{s.t.} \\quad p_1 x_1 + p_2 x_2 = m $$\n\nAs illustrated in the notes, we can solve this problem by formulating the Lagrangian and solving the first-order conditions, leading to the following optimal values for $x_1$ and $x_2$:\n\n$$ x_1^* = \\frac{\\alpha}{\\alpha + \\beta} \\frac{m}{p_1}, \\quad x_2^* = \\frac{\\beta}{\\alpha + \\beta} \\frac{m}{p_2} $$\n\nWe will make a simplification and assume $\\beta = 1 - \\alpha$, so we have:\n\n$$ x_1^* = \\frac{\\alpha m}{p_1}, \\quad x_2^* = \\frac{(1-\\alpha) m}{p_2} $$\n\nThus, the utility-maximizing values of $x_1$ and $x_2$ allocate an $\\alpha$ fraction of income to good 1 and a $(1-\\alpha)$ fraction to good 2.\n\n## Optimization by Hand\n\nTo begin, we'll code the expressions we solved manually above to perform some comparative statics. Let's write a Python function, `solve_by_hand`, that outputs the values of $x_1$ and $x_2$ as a function of the parameters $\\alpha$, $m$, $p_1$, and $p_2$ based on the above expressions.\n\n::: {#981becc9 .cell execution_count=1}\n``` {.python .cell-code}\ndef solve_by_hand(alpha, m, p1, p2):\n    x1 = alpha * m / p1\n    x2 = (1 - alpha) * m / p2\n    return x1, x2\n```\n:::\n\n\nLet's test this function at the following parameter values: \n$$\\alpha = 0.5, \\ m = 100, \\ p_1 = 5, \\ p_2 = 10$$\nWe should get $x_1^* = 0.5 \\times 100/5 = 10$ and $x_2^* = 0.5 \\times 100/10 = 5$.\n\n::: {#7731631b .cell execution_count=2}\n``` {.python .cell-code}\n# Parameters\nalpha = 0.5\nm = 100\np1 = 5\np2 = 10\n\n# Solve for the optimal values of x1 and x2\nx1, x2 = solve_by_hand(alpha, m, p1, p2)\n\n# Print the results (round to 2 decimal places)\nprint(f\"Demand for good 1: {round(x1, 2)}\")\nprint(f\"Demand for good 2: {round(x2, 2)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDemand for good 1: 10.0\nDemand for good 2: 5.0\n```\n:::\n:::\n\n\nNext, we'll perform some comparative statics:\n\na. We'll plot the demand for good 1 as a function of its price, keeping the other parameters fixed at the values specified above.\nb. Then, we'll add another curve to the same plot, this time with $m = 200$.\n\n::: {#0abcd52a .cell execution_count=3}\n``` {.python .cell-code}\n# Import necessary libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create a vector of 25 prices for good 1 between 1 and 10\nK = 25 # Number of points\np1_vals = np.linspace(1, 10, K)\n\n# Solve for demand at each price value\nx1_vals, x2_vals = solve_by_hand(alpha, m, p1_vals, p2)\n\n# Plot demand for good 1 as a function of price of good 1\nplt.plot(p1_vals, x1_vals)\nplt.xlabel('Price of good 1')\nplt.ylabel('Demand for good 1')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](project_files/figure-html/cell-4-output-1.png){width=361 height=282}\n:::\n:::\n\n\nThis gives us the standard downward-sloping demand curve. Now, let's overlay a second demand curve for the case when income is $m = 200$.\n\n::: {#3439ac37 .cell execution_count=4}\n``` {.python .cell-code}\n# Calculate demand when m = 200\nx1_vals2, x2_vals2 = solve_by_hand(alpha, 200, p1_vals, p2)\n\n# Create a new plot with the second curve\nplt.plot(p1_vals, x1_vals, label='m = 100')\nplt.plot(p1_vals, x1_vals2, label='m = 200')\nplt.xlabel('Price of good 1')\nplt.ylabel('Demand for good 1')\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](project_files/figure-html/cell-5-output-1.png){width=370 height=282}\n:::\n:::\n\n\nNote that, since the demand for good 2 is independent of the price of good 1, both the vectors `x2_vals` and `x2_vals2` will remain constant.\n\n## Optimization using Python\n\nSo far, we’ve seen how programming allows us to express quantities from our model and perform comparative statics to understand how they respond to changes in parameters. For instance, by plotting the demand curve above, we can quickly observe that the demand for good 1 decreases with price at a diminishing rate.\n\nUp to this point, we solved the expressions manually and then implemented them in Python. However, in many economic models, the expressions can become too complex to solve analytically, making it more practical to code the models directly to gain insights without explicitly solving them. While our problem can be solved analytically, we’ll still learn how to use Python to solve it without relying on analytical expressions for $x_1$ and $x_2$, to get a sense of how to approach more complex models.\n\nWe will first fix the parameters at following values:\n$$\\alpha = 0.5, \\ m = 100, \\ p_1 = 5, \\ p_2 = 10$$\n\nand write the code to solve for the optimal values of $x_1$ and $x_2$ using the `minimize` function from the `scipy.optimize` library. We will then embed this code in a function called `solve_demand` that takes the parameters as inputs and returns the optimal values of $x_1$ and $x_2$.\n\n::: {#76e42b7a .cell execution_count=5}\n``` {.python .cell-code}\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# Parameters\nalpha = 0.5\nm = 100\np1 = 5\np2 = 10\n\n# Utility function\ndef utility(x):\n    x1, x2 = x\n    return -x1 ** alpha * x2 ** (1 - alpha)\n\n# Budget constraint\ndef budget_constraint(x):\n    x1, x2 = x\n    return m - p1 * x1 - p2 * x2\n\n# Specify the constraints and initial guess\nconstraints = ({\"type\": \"eq\", \"fun\": budget_constraint})\ninitial_guess = [1, 2] \n\n# Use minimize from scipy to solve for the optimal values of x1 and x2\nresult = minimize(utility, initial_guess, constraints=constraints)\nx1, x2 = result.x\n\n# Print the results (round to 2 decimal places)\nprint(f\"Demand for good 1: {round(x1, 2)}\")\nprint(f\"Demand for good 2: {round(x2, 2)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDemand for good 1: 10.0\nDemand for good 2: 5.0\n```\n:::\n:::\n\n\nNote: The utility function is defined as negative because we are maximizing utility, so we are effectively minimizing the negative of the utility function.\n\nIn the code above, we simply provided the computer with our objective function and constraints, and it solved for the optimal values of $x_1$ and $x_2$ given a set of parameters. This means we didn’t need to solve the first-order conditions by hand. Of course, we don’t get an analytical expression for how demand depends on income and prices as we did before. However, we can extend this approach by embedding the code in a function that takes the parameters as inputs and returns the optimal values. This way, we can plot the quantities for different parameter values and gain insights into how the optimal quantities depend on prices and income.\n\n::: {#f2189be7 .cell execution_count=6}\n``` {.python .cell-code}\ndef solve_demand(alpha, m, p1, p2):\n    \n    def utility(x):\n        x1, x2 = x\n        return -(x1**alpha) * x2 ** (1 - alpha)\n    \n    def budget_constraint(x):\n        x1, x2 = x\n        return m - p1 * x1 - p2 * x2\n    \n    constraints = ({\"type\": \"eq\", \"fun\": budget_constraint})\n    initial_guess = [1, 2]\n    result = minimize(utility, initial_guess, constraints=constraints)\n    x1, x2 = result.x\n    \n    return round(x1, 2), round(x2, 2)\n```\n:::\n\n\nLet's test the function with the same parameters as before.\n\n::: {#5263a24c .cell execution_count=7}\n``` {.python .cell-code}\nm = 100\np1 = 5\np2 = 10\nalpha = 0.5\nx1, x2 = solve_demand(alpha, m, p1, p2)\nprint(f\"Demand for good 1: {x1}\")\nprint(f\"Demand for good 2: {x2}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDemand for good 1: 10.0\nDemand for good 2: 5.0\n```\n:::\n:::\n\n\nNow that we have the function `solve_demand`, we can use it to plot the demand for good 1 as a function of its price, similar to what we did earlier.\n\n::: {#c9e5a91a .cell execution_count=8}\n``` {.python .cell-code}\n# Apply function to a range of prices for good 1\nx = [solve_demand(alpha, m, p1, p2) for p1 in p1_vals]\nx1_vals3, x2_vals3 = np.array(x).T\n\n# Plot demand curves\nplt.plot(p1_vals, x1_vals3, label='Demand for good 1')\nplt.plot(p1_vals, x2_vals3, label='Demand for good 2')\nplt.xlabel('Price of good 1')\nplt.ylabel('Demand')\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](project_files/figure-html/cell-9-output-1.png){width=361 height=282}\n:::\n:::\n\n\n# Exercise \nThe utility function used in the above example is called a Cobb-Douglas function. In this exercise, we will consider utility maximization with a CES utility function. In particular, the CES utility function is given by:\n\n$$ U(x_1, x_2) = \\left( \\alpha x_1^{\\rho} + (1 - \\alpha) x_2^{\\rho} \\right)^{1/\\rho} $$\n\nHere,\n\n-  $\\alpha$  is a parameter between 0 and 1 that reflects the relative weight or importance of the goods.\n-  $\\rho$ controls how easily the consumer can substitute between the two goods.\n   -  When $\\rho \\to 1$, the goods are perfect substitutes.\n   -  When $\\rho \\to -\\infty$, the goods are perfect complements.\n\nAlso, note that the Cobb-Douglas utility function is a special case of the CES utility function with $\\rho \\to 0$.\n\nEach part is worth 2.5 points.\n\n1.  Modify the `solve_demand` function to create a new function, `solve_demand_ces`, which solves for the optimal quantities of good 1 and good 2 given the CES utility function. (This new function will include an additional parameter, $\\rho$.) \n2.  Find the optimal $x_1$ and $x_2$ at the following parameter values: $\\alpha = 0.5, \\rho = 0.99, \\ m = 100, \\ p_1 = 5, \\ p_2 = 10$. Print the results. How do these values change if $\\rho=0.001$ and when $\\rho = -200$?\n3. Plot the demand for good 2 as a function of the price of good 1 for the CES utility function with same parameters as in part 2. But in the case of $\\rho = 0.5$ and $\\rho=-1$.  \n4.  If I was using this utility function to model the demand for Heinz ketchup and French's mustard, which case would be more appropriate: $\\rho = 0.5$ or $\\rho = -1$? Now what if I was modeling the demand for Heinz ketchup and Hunts ketchup, which case would be more appropriate: $\\rho = 0.5$ or $\\rho = -1$? Explain your answer.\n\nSubmit Jupyter notebook with the code and the answers to the questions.\n\n## Solution\n\n::: {#2a60fdff .cell execution_count=9}\n``` {.python .cell-code}\ndef solve_demand_ces(alpha, rho, m, p1, p2):\n    \n    def utility(x):\n        x1, x2 = x\n        return -(alpha * x1 ** rho + (1 - alpha) * x2 ** rho) ** (1 / rho)\n    \n    def budget_constraint(x):\n        x1, x2 = x\n        return m - p1 * x1 - p2 * x2\n    \n    constraints = ({\"type\": \"eq\", \"fun\": budget_constraint})\n    initial_guess = [1, 2]\n    result = minimize(utility, initial_guess, constraints=constraints)\n    x1, x2 = result.x\n    \n    return round(x1, 2), round(x2, 2)\n```\n:::\n\n\n::: {#3e87d100 .cell execution_count=10}\n``` {.python .cell-code}\n# Parameters\nalpha = 0.5\nm = 100\np1 = 5\np2 = 10\n\nx1, x2 = solve_demand_ces(alpha, 0.99, m, p1, p2)\nprint(f\"Good 1: {x1}\", f\"Good 2: {x2}\")\n\nx1, x2 = solve_demand_ces(alpha, 0.001, m, p1, p2)\nprint(f\"Good 1: {x1}\", f\"Good 2: {x2}\")\n\nx1, x2 = solve_demand_ces(alpha, -200, m, p1, p2)\nprint(f\"Good 1: {x1}\", f\"Good 2: {x2}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGood 1: 20.0 Good 2: 0.0\nGood 1: 10.0 Good 2: 5.0\nGood 1: 6.68 Good 2: 6.66\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n/var/folders/m0/81ww_p5n651_dc02g0cwpk2w0000gq/T/ipykernel_93683/3369636418.py:5: RuntimeWarning:\n\ninvalid value encountered in scalar power\n\n```\n:::\n:::\n\n\n::: {#01b76225 .cell execution_count=11}\n``` {.python .cell-code}\n# Create a vector of 25 prices for good 1 between 1 and 10\nK = 25 # Number of points\np1_vals = np.linspace(1, 10, K)\n\nrho = -1\n# Calculate demand for good 1 and good 2 at each price value\nx = [solve_demand_ces(alpha, rho, m, p1, p2) for p1 in p1_vals]\nx1_vals, x2_vals = np.array(x).T\n\n# Plot demand for good 1 as a function of price of good 1\nplt.plot(p1_vals, x2_vals)\nplt.xlabel('Price of good 1')\nplt.ylabel('Demand for good 2')\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nText(0, 0.5, 'Demand for good 2')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](project_files/figure-html/cell-12-output-2.png){width=366 height=282}\n:::\n:::\n\n\n",
    "supporting": [
      "project_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}