{
  "hash": "0c6c1a0ac174493b65b17a1797e1947f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Tutorial 2: Optimization in Python\"\nnav-sidebar: false\nfig-align: center\nfig-width: 4\nfig-height: 3\n---\n\n\n\n\n<!-- Before, we get started with the tutorial, note that you can launch the content of this page in a [Google Colab](https://colab.research.google.com) notebook by clicking here. This will allow you to run the code interactively and make changes to the code. -->\n\nIn this tutorial, we’ll work through example 1 from the constrained optimization problems provided [here](Notes/Optimization-Examples.pdf). In particular, our optimization problem is as follows:\n\n$$ \\max_{x_1, x_2} \\quad x_1^{\\alpha} x_2^{\\beta} \\quad \\text{s.t.} \\quad p_1 x_1 + p_2 x_2 = m $$\n\nAs illustrated in the notes, we can solve this problem by formulating the Lagrangian and solving the first-order conditions, leading to the following optimal values for $x_1$ and $x_2$:\n\n$$ x_1^* = \\frac{\\alpha}{\\alpha + \\beta} \\frac{m}{p_1}, \\quad x_2^* = \\frac{\\beta}{\\alpha + \\beta} \\frac{m}{p_2} $$\n\nWe will make a simplification and assume $\\beta = 1 - \\alpha$, so we have:\n\n$$ x_1^* = \\frac{\\alpha m}{p_1}, \\quad x_2^* = \\frac{(1-\\alpha) m}{p_2} $$\n\nThus, the utility-maximizing values of $x_1$ and $x_2$ allocate an $\\alpha$ fraction of income to good 1 and a $(1-\\alpha)$ fraction to good 2.\n\n**Note**: You should copy-paste the code snippets below into a Google Colab notebook and run them to see the output while you read through the tutorial.\n\n## Optimization by Hand\n\nTo begin, we'll code the expressions we solved manually above to perform some comparative statics. Let's write a Python function, `solve_by_hand`, that outputs the values of $x_1$ and $x_2$ as a function of the parameters $\\alpha$, $m$, $p_1$, and $p_2$ based on the above expressions.\n\n::: {#ac0cdb38 .cell execution_count=1}\n``` {.python .cell-code}\ndef solve_by_hand(alpha, m, p1, p2):\n    x1 = alpha * m / p1\n    x2 = (1 - alpha) * m / p2\n    return x1, x2\n```\n:::\n\n\nLet's test this function at the following parameter values: \n$$\\alpha = 0.5, \\ m = 100, \\ p_1 = 5, \\ p_2 = 10$$\nWe should get $x_1^* = 0.5 \\times 100/5 = 10$ and $x_2^* = 0.5 \\times 100/10 = 5$.\n\n::: {#9f660139 .cell execution_count=2}\n``` {.python .cell-code}\n# Parameters\nalpha = 0.5\nm = 100\np1 = 5\np2 = 10\n\n# Solve for the optimal values of x1 and x2\nx1, x2 = solve_by_hand(alpha, m, p1, p2)\n\n# Print the results (round to 2 decimal places)\nprint(f\"Demand for good 1: {round(x1, 2)}\")\nprint(f\"Demand for good 2: {round(x2, 2)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDemand for good 1: 10.0\nDemand for good 2: 5.0\n```\n:::\n:::\n\n\nNext, we'll perform some comparative statics:\n\na. We'll plot the demand for good 1 as a function of its price, keeping the other parameters fixed at the values specified above.\nb. Then, we'll add another curve to the same plot, this time with $m = 200$.\n\n::: {#54f7e498 .cell execution_count=3}\n``` {.python .cell-code}\n# Import necessary libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create a vector of 25 prices for good 1 between 1 and 10\np1_vals = np.linspace(1, 10, 25)\n\n# Solve for demand at each price value\nx1_vals, x2_vals = solve_by_hand(alpha, m, p1_vals, p2)\n\n# Plot demand for good 1 as a function of price of good 1\nplt.plot(p1_vals, x1_vals)\nplt.xlabel('Price of good 1')\nplt.ylabel('Demand for good 1')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](tutorial2_files/figure-html/cell-4-output-1.png){width=361 height=282}\n:::\n:::\n\n\nThis gives us the standard downward-sloping demand curve. Now, let's overlay a second demand curve for the case when income is $m = 200$.\n\n::: {#6f67f705 .cell execution_count=4}\n``` {.python .cell-code}\n# Calculate demand when m = 200\nx1_vals2, x2_vals2 = solve_by_hand(alpha, 200, p1_vals, p2)\n\n# Create a new plot with the second curve\nplt.plot(p1_vals, x1_vals, label='m = 100')\nplt.plot(p1_vals, x1_vals2, label='m = 200')\nplt.xlabel('Price of good 1')\nplt.ylabel('Demand for good 1')\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](tutorial2_files/figure-html/cell-5-output-1.png){width=370 height=282}\n:::\n:::\n\n\nNote that, since the demand for good 2 is independent of the price of good 1, both the vectors `x2_vals` and `x2_vals2` will remain constant.\n\n## Optimization using Python\n\nSo far, we’ve seen how programming allows us to express quantities from our model and perform comparative statics to understand how they respond to changes in parameters. For instance, by plotting the demand curve above, we can quickly observe that the demand for good 1 decreases with price at a diminishing rate.\n\nUp to this point, we solved the expressions manually and then implemented them in Python. However, in many economic models, the expressions can become too complex to solve analytically, making it more practical to code the models directly to gain insights without explicitly solving them. While our problem can be solved analytically, we’ll still learn how to use Python to solve it without relying on analytical expressions for $x_1$ and $x_2$, to get a sense of how to approach more complex models.\n\nWe will first fix the parameters at following values:\n$$\\alpha = 0.5, \\ m = 100, \\ p_1 = 5, \\ p_2 = 10$$\n\nand write the code to solve for the optimal values of $x_1$ and $x_2$ using the `minimize` function from the `scipy.optimize` library. We will then embed this code in a function called `solve_demand` that takes the parameters as inputs and returns the optimal values of $x_1$ and $x_2$.\n\n::: {#0113d955 .cell execution_count=5}\n``` {.python .cell-code}\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# Parameters\nalpha = 0.5\nm = 100\np1 = 5\np2 = 10\n\n# Utility function\ndef utility(x):\n    x1, x2 = x\n    if x1 < 0 or x2 < 0:\n        return np.inf\n    else:\n        return -x1 ** alpha * x2 ** (1 - alpha)\n\n# Budget constraint\ndef budget_constraint(x):\n    x1, x2 = x\n    return m - p1 * x1 - p2 * x2\n\n# Specify the constraints and initial guess\nconstraints = ({\"type\": \"eq\", \"fun\": budget_constraint})\ninitial_guess = [1, 2] \n\n# Use minimize from scipy to solve for the optimal values of x1 and x2\nresult = minimize(utility, initial_guess, constraints=constraints)\nx1, x2 = result.x\n\n# Print the results (round to 2 decimal places)\nprint(f\"Demand for good 1: {round(x1, 2)}\")\nprint(f\"Demand for good 2: {round(x2, 2)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDemand for good 1: 10.0\nDemand for good 2: 5.0\n```\n:::\n:::\n\n\nNote: The utility function is defined as negative because we are maximizing utility, so we are effectively minimizing the negative of the utility function.\n\nIf we also wanted to bake in the constraint that $x_1$ and $x_2$ must be non-negative, we can modify the `utility` function to return a really large value if $x_1$ or $x_2$ is negative. This way, the optimizer will avoid negative values for $x_1$ and $x_2$. The modified utility function would be defined as follows:\n\n::: {#ef92a41f .cell execution_count=6}\n``` {.python .cell-code}\ndef utility(x):\n    x1, x2 = x\n    if x1 < 0 or x2 < 0:\n        return np.inf\n    else:\n        return -x1 ** alpha * x2 ** (1 - alpha)\n```\n:::\n\n\nIn the code above, we simply provided the computer with our objective function and constraints, and it solved for the optimal values of $x_1$ and $x_2$ given a set of parameters. This means we didn’t need to solve the first-order conditions by hand. Of course, we don’t get an analytical expression for how demand depends on income and prices as we did before. However, we can extend this approach by embedding the code in a function that takes the parameters as inputs and returns the optimal values. This way, we can plot the quantities for different parameter values and gain insights into how the optimal quantities depend on prices and income.\n\n::: {#83a523ce .cell execution_count=7}\n``` {.python .cell-code}\ndef solve_demand(alpha, m, p1, p2):\n    \n    def utility(x):\n        x1, x2 = x\n        if x1 < 0 or x2 < 0:\n            return np.inf\n        else:\n            return -x1 ** alpha * x2 ** (1 - alpha)\n    \n    def budget_constraint(x):\n        x1, x2 = x\n        return m - p1 * x1 - p2 * x2\n    \n    constraints = ({\"type\": \"eq\", \"fun\": budget_constraint})\n    initial_guess = [1, 2]\n    result = minimize(utility, initial_guess, constraints=constraints)\n    x1, x2 = result.x\n    \n    return round(x1, 2), round(x2, 2)\n```\n:::\n\n\nLet's test the function with the same parameters as before.\n\n::: {#46c35a69 .cell execution_count=8}\n``` {.python .cell-code}\nm = 100\np1 = 5\np2 = 10\nalpha = 0.5\nx1, x2 = solve_demand(alpha, m, p1, p2)\nprint(f\"Demand for good 1: {x1}\")\nprint(f\"Demand for good 2: {x2}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDemand for good 1: 10.0\nDemand for good 2: 5.0\n```\n:::\n:::\n\n\nNow that we have the function `solve_demand`, we can use it to plot the demand for good 1 as a function of its price, similar to what we did earlier.\n\n::: {#21ac89e8 .cell execution_count=9}\n``` {.python .cell-code}\n# Apply function to a range of prices for good 1\nx = [solve_demand(alpha, m, p1, p2) for p1 in p1_vals]\nx1_vals3, x2_vals3 = np.array(x).T\n\n# Plot demand curves\nplt.plot(p1_vals, x1_vals3, label='Demand for good 1')\nplt.plot(p1_vals, x2_vals3, label='Demand for good 2')\nplt.xlabel('Price of good 1')\nplt.ylabel('Demand')\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](tutorial2_files/figure-html/cell-10-output-1.png){width=361 height=282}\n:::\n:::\n\n\n",
    "supporting": [
      "tutorial2_files"
    ],
    "filters": [],
    "includes": {}
  }
}