{
  "hash": "1cb81663e072efaa500fe73a31f8bb41",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Project\"\nformat:\n  html:\n    anchor-sections: true\n---\n\n\n\nIf you are taking this course for graduate credit, you will need to complete a project. The grade for the project will count in place of the active engagement grade. The project is due on the last day of class. You only need to complete this assignment if you are graduate student taking this course for credit, undergraduate students are not required to complete this assignment, but can do so for fun and I would be happy to check your work, but it will not count towards your grade.\n\nThis project will teach you how to use Python programming to solve a simple mathematical problem with some economic intution. \n\nBefore you get started, you need to know some basics of Python programming below and also complete the tutorial on optimization in Python. In particular, the tutorial shows code for example, you will be modifying that code to solve a related but expanded problem. Once you are done with the two tutorials, you can start the project. You will find the instructions for the exercise you need to complete at the end of this document.\n\n\n# Tutorial 1: Basic Python Setup\n\n- Python is...\n- Usually how it works, you run something vs running on cloud\n- .py files and notebook files\n- I will not teach you workflow becuase this is not a programming class, but if you ever want to do anything serious, you need to learn that. \n- What we will do and see how programming can be used to solve economic models. \n- So we will use the simplest setup possible, which you should also be familar from your other classes, which is to use Jupyter notebook on Google Colab.\n\nYou can always play around with the code below and run it, modify it, etc. But remember once you refresh it it goes back to the original code. You can also copy code to your Jupyter notebooks in Google Colab and modify it there.\n\n```{pyodide-python}\nn = 5\nwhile n > 0:\n  print(n)\n  n = n - 1\n\nprint('Blastoff!')\n```\n\n## Packages and Syntax\n\n## Lists/vectors\n\n## Loops\n\n## Functions\n\n## Plots \n\n# Tutorial 2: Optimization in Python\n\n## Optimization by Hand\n\nExample 1 for constrained maximization (add link), we derived demand functions for good 1 and 2 given a utility function.\n\n$$ x_1^* = \\frac{\\alpha}{\\alpha + \\beta} \\frac{m}{p_1}, \\quad x_2^* = \\frac{\\beta}{\\alpha + \\beta} \\frac{m}{p_2} $$\n\nAssume $\\beta = 1 - \\alpha$.\n\n$$ x_1^* = \\frac{\\alpha m}{p_1}, \\quad x_2^* = \\frac{(1-\\alpha) m}{p_2} $$\n\nNote that $m = p_1 x_1 + p_2 x_2$ is the budget constraint. $\\alpha$ determines the share of expenditure on good 1. What is the value x1 and x2 for $\\alpha = 0.5$, $m = 100$, $p_1 = 5$, and $p_2 = 5$, should be x1 = 10 and x2 = 10.\n\n1. Write a function in python that gives x_1 and x_2 as function of $\\alpha$, $m$, $p_1$, and $p_2$. Call this function `solve_by_hand` as we solved the expressions for demand by hand are then coding that in Python. Once we write the function, we will also test it with the following parameters: $\\alpha = 0.5$, $m = 100$, $p_1 = 5$, and $p_2 = 5$.\n\n::: {#solve_by_hand .cell execution_count=1}\n``` {.python .cell-code}\n# Define the function\ndef solve_by_hand(alpha, m, p1, p2):\n    x1 = alpha * m / p1\n    x2 = (1 - alpha) * m / p2\n    return x1, x2\n\n# Implement the function\nalpha = 0.5\nm = 100\np1 = 5\np2 = 5\nx1, x2 = solve_by_hand(alpha, m, p1, p2)\n\n# Print the results (round to 2 decimal places)\nx1, x2 = round(x1, 2), round(x2, 2)\nprint(f\"Demand for good 1: {x1}\")\nprint(f\"Demand for good 2: {x2}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDemand for good 1: 10.0\nDemand for good 2: 10.0\n```\n:::\n:::\n\n\n2. Now let's do some comparative statics. \n    - a. We will plot demand for good 1 as a function of price of good 1 fixing other parameters at above values.\n    - b. Add another curve to the existing plot 1, where m = 200.\n\n::: {#8c91d054 .cell depends='solve_by_hand' execution_count=2}\n``` {.python .cell-code}\n# Import necessary libraries\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Create a vector of 25 price values for good 1 between 1 and 10\nK = 25 # Number of points\np1_vals = np.linspace(1, 10, K)\n\n# Calculate demand for goods for each price value in a loop\nx1_vals = np.zeros(K)\nx2_vals = np.zeros(K)\nfor i in range(K):\n    x1_vals[i], x2_vals[i] = solve_by_hand(alpha, m, p1_vals[i], p2)\n\n# Plot demand for good 1 as a function of price of good 1\nplt.plot(p1_vals, x1_vals)\nplt.xlabel('Price of good 1')\nplt.ylabel('Demand for good 1')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](project_files/figure-html/comparative_statics-output-1.png){#comparative_statics width=585 height=429}\n:::\n:::\n\n\nSo we get out regular downward sloping demand curve. Now let's add the second curve where m = 200.\n\n::: {#087f0de0 .cell depends='comparative_statics' execution_count=3}\n``` {.python .cell-code}\n# Calculate demand for goods for each price value in a loop with m = 200\nx1_vals2 = np.zeros(K)\nx2_vals2 = np.zeros(K)\nfor i in range(K):\n    x1_vals2[i], x2_vals2[i] = solve_by_hand(alpha, 2*m, p1_vals[i], p2)\n\n# Create a new plot with the second curve\nplt.plot(p1_vals, x1_vals, label='m = 100')\nplt.plot(p1_vals, x1_vals2, label='m = 200')\nplt.xlabel('Price of good 1')\nplt.ylabel('Demand for good 1')\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](project_files/figure-html/comparative_statics2-output-1.png){#comparative_statics2 width=593 height=429}\n:::\n:::\n\n\n## Optimization using Python\n\nWe saw it can be useful to do comparative statics, etc using a computer than by hand. But for now we solved the expressions by hand and then coded them in Python. Sometimes the expressions are too complicated to solve by hand in economic models, and it can useful to just code up the models to get useful insights, without explicitly solving the model. This is bery common for complex macroeconomic models, which are sometimes only possible to solve using numerical methods. While our problem can be solved analytically, we will still learn how to use Python to solve to get a taste of how to solve more complex models.\n\nWe will first fix $alpha = 0.5$, $m = 100$, $p_1 = 5$, and $p_2 = 5$ and use minimize from scipy to solve for the optimal values of $x_1$ and $x_2$. Then as before we will use our logic and write a function to solve for demand given the parameters. Call this function `solve_demand`.\n\n::: {#solve_in_python .cell execution_count=4}\n``` {.python .cell-code}\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# Parameters\nalpha = 0.5\nm = 100\np1 = 5\np2 = 5\n\n# Utility function\ndef utility(x):\n    x1, x2 = x\n    return -x1 ** alpha * x2 ** (1 - alpha)\n\n# Budget constraint\ndef budget_constraint(x):\n    x1, x2 = x\n    return m - p1 * x1 - p2 * x2\n\n# Specify the constraints and initial guess\nconstraints = ({\"type\": \"eq\", \"fun\": budget_constraint})\ninitial_guess = [1, 2] \n\n# Use minimize from scipy to solve for the optimal values of x1 and x2\nresult = minimize(utility, initial_guess, constraints=constraints)\nx1, x2 = result.x\n\n# Print the results (round to 2 decimal places)\nprint(f\"Demand for good 1: {round(x1, 2)}\")\nprint(f\"Demand for good 2: {round(x2, 2)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDemand for good 1: 10.0\nDemand for good 2: 10.0\n```\n:::\n:::\n\n\nSo in this case, we just told the computer out objective function and constraints and it solved for the optimal values of $x_1$ and $x_2$ for a given set of parameters. The computer can also plot the function for us and tell us how x1 and x2 change with parameters, but off course it can only do so numerically, not give us the exact expressions. But in a lot of cases, that is all we need.\n\nNote that we actually defined neg of utility as function to minimize, since we want to maximize utility.\n\nNow that we know how to solve for demand using Python, let's actually define a function using the logic above to solve for demand given the parameters. Essentially just enveloping the code above in a function.\n\n::: {#solve_demand .cell depends='solve_in_python' execution_count=5}\n``` {.python .cell-code}\n# Define the function\ndef solve_demand(alpha, m, p1, p2):\n    def utility(x):\n        x1, x2 = x\n        return -(x1**alpha) * x2 ** (1 - alpha)\n    def budget_constraint(x):\n        x1, x2 = x\n        return m - p1 * x1 - p2 * x2\n    constraints = ({\"type\": \"eq\", \"fun\": budget_constraint})\n    initial_guess = [2, 5]\n    result = minimize(utility, initial_guess, constraints=constraints)\n    x1, x2 = result.x\n    return round(x1, 2), round(x2, 2)\n\n\n# Implement the function\nm = 100\np1 = 5\np2 = 5\nalpha = 0.5\nx1, x2 = solve_demand(alpha, m, p1, p2)\n\nprint(f\"Demand for good 1: {x1}\")\nprint(f\"Demand for good 2: {x2}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDemand for good 1: 10.0\nDemand for good 2: 10.0\n```\n:::\n:::\n\n\nNow again you can plot demand for each good as a function of it's price aka demand curve. And also see how this changes with income, shifts right. \n\n::: {#7ee7d7ad .cell execution_count=6}\n``` {.python .cell-code}\n# Apply function in loop for different prices of good 1\nx1vals1 = np.zeros(K)\nx1vals2 = np.zeros(K)\nfor i in range(K):\n    x1vals1[i], _ = solve_demand(alpha, m, p1_vals[i], p2)\n    x1vals2[i], _ = solve_demand(alpha, 2*m, p1_vals[i], p2)\n\n# Plot demand curves\nplt.plot(p1_vals, x1vals1, label='m = 100')\nplt.plot(p1_vals, x1vals2, label='m = 200')\nplt.xlabel('Price of good 1')\nplt.ylabel('Demand')\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](project_files/figure-html/cell-7-output-1.png){width=593 height=429}\n:::\n:::\n\n\n# Exercise \n\nIn this exercise, we will consider utility maximization with a CES utility function. The function used in the above example is called a Cobb-Douglas utility function, which is a special case of the CES utility function. \n\nIn particular, the utility function is given by:\n$$ U(x_1, x_2) = \\left( \\alpha x_1^{\\rho} + (1 - \\alpha) x_2^{\\rho} \\right)^{1/\\rho} $$\n\nWhere $x_1$ and $x_2$ are the quantities of good 1 and good 2 consumed, respectively. $\\alpha$ is the share of expenditure on good 1, $\\rho$ is the elasticity of substitution between the two goods.\n\n- stuff about CES function, elasticity of substitution, etc.\n\nEach part is worth 2.5 points.\n\n1.  Modify `solve_demand` to create a function called `solve_demand_ces` that solves for the demand of good 1 and good 2 given the CES utility function.\n2. Plot the own demand and cross demand curves for good 1 and good 2 as a function of the price of good 1 and good 2. Put these plots in a 2x2 grid with appropriate labels and titles. \n3. Verify that the demand for good 1 and good 2 same as when using solve_demand function when rho very small ie. close to 0.001.\n4.  When rho really large (try a big number like 100), what happens to the demand for good 1 and good 2? Try a number close to 1 (like 0.95)\n5.  Write a short paragraph explaining that if price of Heinz ketchup goes up, what happens to the demand for French's mustard, if the two are complements. \n\n",
    "supporting": [
      "project_files"
    ],
    "filters": [],
    "includes": {}
  }
}